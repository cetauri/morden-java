[
["method-reference.html", "Chapter 3 Method Reference 3.1 Constractor", " Chapter 3 Method Reference 기존 메소드 재사용이 가능하다 Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) .stream() .anyMatch(&quot;c&quot;::equals); 3.1 Constractor final Function sectionFactoryWithMethodReference = Section::new; sectionFactoryWithMethodReference.apply(1, “Name”, “address”); @AllArgsConstructor @Data abstract class Product { private Long id; private String name; private BigDecimal price; } class ProductA extends Product { public ProductA(final Long id, final String name, final BigDecimal price) { super(id, name, price); } @Override public String toString() { return &quot;A=&quot; + super.toString(); } } class ProductB extends Product { public ProductB(final Long id, final String name, final BigDecimal price) { super(id, name, price); } @Override public String toString() { return &quot;B=&quot; + super.toString(); } } @FunctionalInterface interface ProductCreator&lt;T extends Product&gt; { T create(Long id, String name, BigDecimal price); } private static &lt;T extends Product&gt; T createProduct(final Long id, final String name, final BigDecimal price, final ProductCreator&lt;T&gt; productCreator) { if (id == null || id &lt; 1L) { throw new IllegalArgumentException(&quot;The id must be a positive Long.&quot;); } if (name == null || name.isEmpty()) { throw new IllegalArgumentException(&quot;The name is not given.&quot;); } if (price == null || price.compareTo(BigDecimal.ZERO) &lt;= 0) { // price &lt;= ZERO throw new IllegalArgumentException(&quot;The price must be greater then 0.&quot;); } return productCreator.create(id, name, price); } final ProductA a = createProduct(1L, &quot;A&quot;, new BigDecimal(&quot;123&quot;), ProductA::new); final ProductB b = createProduct(2L, &quot;B&quot;, new BigDecimal(&quot;111&quot;), ProductB::new); "]
]
